# Порівняння алгоритмів для видачі решти

## Реалізація

### Жадібний алгоритм
Функція `find_coins_greedy` працює за наступним принципом:
- Сортує номінали монет у порядку спадання.
- Використовує найбільші доступні номінали монет, щоб досягти заданої суми.

### Алгоритм динамічного програмування
Функція `find_min_coins` використовує таблицю для зберігання мінімальної кількості монет для кожної можливої суми:
- Ініціалізує таблицю з початковими значеннями.
- Оновлює таблицю, знаходячи мінімальну кількість монет для кожної суми до заданої.
- Відслідковує, які монети були використані для формування суми.

## Порівняння ефективності

### Час виконання

#### Жадібний алгоритм
- Часова складність: O(n log n + k), де n - кількість номіналів монет, k - сума, яку потрібно видати. Сортування монет має складність O(n log n), а сам алгоритм перебирає монети за O(k).
- Простий у реалізації та швидкий для невеликих сум.

#### Динамічне програмування
- Часова складність: O(n * k), де n - кількість номіналів монет, k - сума, яку потрібно видати. Для кожної суми до k перевіряється кожен номінал монет.
- Вимагає більше часу та пам'яті, особливо для великих сум.

### Продуктивність при великих сумах
- Жадібний алгоритм може бути менш ефективним для великих сум, оскільки він не завжди знаходить оптимальне рішення. Наприклад, для монет [9, 6, 1] жадібний алгоритм для суми 11 дасть [9, 1, 1] замість оптимального [6, 6].
- Алгоритм динамічного програмування завжди знаходить оптимальне рішення, але може бути повільним для дуже великих сум через використання великої таблиці.

## Висновок
Жадібний алгоритм є швидким та простим у реалізації, але не завжди знаходить оптимальне рішення. Алгоритм динамічного програмування завжди знаходить оптимальне рішення, але може бути менш ефективним за часом та пам'яттю для великих сум. Вибір алгоритму залежить від конкретних умов задачі та доступних ресурсів.

